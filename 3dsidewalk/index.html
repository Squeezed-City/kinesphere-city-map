<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Add a 3D model</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
  </style>
</head>
<body>
<script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
<div id="map"></div>
<script>
  mapboxgl.accessToken = 'pk.eyJ1Ijoic2xvbm8iLCJhIjoiY2p6Zmg2dDdlMDZzZTNib280Y3phN29jciJ9.JCddta2wHSt2t71JUVR7UQ';
  const map = new mapboxgl.Map({
      container: 'map',
      // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
      style: 'mapbox://styles/mapbox/light-v11',
      zoom: 10,
      center: [9.1895, 45.4642],  // Milan coordinates
      pitch: 60,
      antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
  });

  // parameters to ensure the model is georeferenced correctly on the map
  const modelOrigin = [9.1895, 45.4642];  // Milan coordinates
  const modelAltitude = 0;
  const modelRotate = [0, 0, Math.PI *0.5];

  const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
      modelOrigin,
      modelAltitude
  );

  // Scale factor
  const xScaleFactor = 50;
  const yScaleFactor = 50;
  const zScaleFactor = 15;

  // transformation parameters to position, rotate and scale the 3D model onto the map
  const modelTransform = {
      translateX: modelAsMercatorCoordinate.x,
      translateY: modelAsMercatorCoordinate.y,
      translateZ: modelAsMercatorCoordinate.z,
      rotateX: modelRotate[0], 
      rotateY: modelRotate[1], // Rotating around the Y-axis to make Y "horizontal"
      rotateZ: modelRotate[2], // No rotation around Z-axis
      scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
  };

  const THREE = window.THREE;

  // configuration of the custom layer for a 3D model per the CustomLayerInterface
  const customLayer = {
      id: '3d-model',
      type: 'custom',
      renderingMode: '3d',
      onAdd: function (map, gl) {
          this.camera = new THREE.Camera();
          this.scene = new THREE.Scene();

          // create two three.js lights to illuminate the model
          const directionalLight = new THREE.DirectionalLight(0xffffff);
          directionalLight.position.set(0, -70, 100).normalize();
          this.scene.add(directionalLight);

          const directionalLight2 = new THREE.DirectionalLight(0xffffff);
          directionalLight2.position.set(0, 70, 100).normalize();
          this.scene.add(directionalLight2);

          // use the three.js GLTF loader to add the 3D model to the three.js scene
          const loader = new THREE.GLTFLoader();
          loader.load(
              'hills.gltf',
              (gltf) => {
                  this.scene.add(gltf.scene);
              }
          );
          this.map = map;

          // use the Mapbox GL JS map canvas for three.js
          this.renderer = new THREE.WebGLRenderer({
              canvas: map.getCanvas(),
              context: gl,
              antialias: true
          });

          this.renderer.autoClear = false;
      },
      render: function (gl, matrix) {
          const rotationX = new THREE.Matrix4().makeRotationAxis(
              new THREE.Vector3(1, 0, 0),
              modelTransform.rotateX
          );
          const rotationY = new THREE.Matrix4().makeRotationAxis(
              new THREE.Vector3(0, 1, 0),
              modelTransform.rotateY
          );
          const rotationZ = new THREE.Matrix4().makeRotationAxis(
              new THREE.Vector3(0, 0, 1),
              modelTransform.rotateZ
          );

          const m = new THREE.Matrix4().fromArray(matrix);
          const l = new THREE.Matrix4()
              .makeTranslation(
                  modelTransform.translateX,
                  modelTransform.translateY,
                  modelTransform.translateZ
              )
              .scale(
                  new THREE.Vector3(
                      modelTransform.scale * xScaleFactor,          // Scale X-axis (unchanged)
                      modelTransform.scale * yScaleFactor,  // Scale Y-axis to 0.3
                      modelTransform.scale * zScaleFactor        
                  )
              )
              .multiply(rotationX)
              .multiply(rotationY)
              .multiply(rotationZ);

          this.camera.projectionMatrix = m.multiply(l);
          this.renderer.resetState();
          this.renderer.render(this.scene, this.camera);
          this.map.triggerRepaint();
      }
  };

  map.on('style.load', () => {
      map.addLayer(customLayer, 'waterway-label');
  });
</script>
</body>
</html>