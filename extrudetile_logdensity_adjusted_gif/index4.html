<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>3D Visualization with Mapbox and Tessellation</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
<script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>

<style>
  body { margin: 0; padding: 0; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1Ijoic2xvbm8iLCJhIjoiY2p6Zmg2dDdlMDZzZTNib280Y3phN29jciJ9.JCddta2wHSt2t71JUVR7UQ';

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/dark-v10',
  center: [9.192254, 45.462633],
  zoom: 15.5,
  minZoom: 15,
  maxZoom: 20,
  pitch: 45,
  bearing: -17.6,
  antialias: true
});

map.on('load', () => {
  map.addSource('density-tileset', {
    'type': 'vector',
    'url': 'mapbox://slono.bj7soaw3'
  });

  map.addLayer({
    'id': 'density-fill',
    'type': 'fill',
    'source': 'density-tileset',
    'source-layer': 'OnlyLog_NormalizedTo100-4zhaka',
    'paint': {
      'fill-color': ['interpolate', ['linear'], ['get', 'logdensity'],
        0, '#0000ff',
        100, '#ff0000'
      ],
      'fill-opacity': 0.0
    }
  });

const customLayer = {
  id: 'custom-tessellated-layer',
  type: 'custom',
  renderingMode: '3d',

  onAdd: function(map, gl) {
    this.map = map;
    this.gl = gl;

    const vertexSource = `#version 300 es
      in vec2 a_pos;
      in float a_logdensity;
      out float v_logdensity;

      uniform mat4 u_matrix;

      void main() {
        v_logdensity = a_logdensity;
        gl_Position = u_matrix * vec4(a_pos, 0.0, 1.0);
      }
    `;

    const fragmentSource = `#version 300 es
      precision mediump float;
      in float v_logdensity;
      out vec4 fragColor;

      void main() {
        float normalizedDensity = v_logdensity / 100.0;
        vec3 color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), normalizedDensity);
        fragColor = vec4(color, 0.7);
      }
    `;

    this.program = gl.createProgram();
    this.setupShaders(vertexSource, fragmentSource);

    this.aPos = gl.getAttribLocation(this.program, "a_pos");
    this.aLogdensity = gl.getAttribLocation(this.program, "a_logdensity");
    this.uMatrix = gl.getUniformLocation(this.program, "u_matrix");

    this.buffer = gl.createBuffer();
  },

  setupShaders: function(vertexSource, fragmentSource) {
    const vertexShader = this.compileShader(vertexSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compileShader(fragmentSource, this.gl.FRAGMENT_SHADER);

    this.gl.attachShader(this.program, vertexShader);
    this.gl.attachShader(this.program, fragmentShader);
    this.gl.linkProgram(this.program);

    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Unable to initialize the shader program:', this.gl.getProgramInfoLog(this.program));
    }
  },

  compileShader: function(source, type) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('An error occurred compiling the shaders:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }

    return shader;
  },

  processPolygon: function(coordinates, logdensity) {
    let data = {vertices: [], holes: [], dimensions: 2};
    let holeIndex = 0;

    coordinates.forEach((ring, i) => {
      if (i > 0) {
        holeIndex += coordinates[i - 1].length;
        data.holes.push(holeIndex);
      }

      ring.forEach(coord => {
        const point = mapboxgl.MercatorCoordinate.fromLngLat(coord);
        data.vertices.push(point.x, point.y);
      });
    });

    const triangles = earcut(data.vertices, data.holes, data.dimensions);

    let vertexData = [];
    for (let i = 0; i < triangles.length; i++) {
      const index = triangles[i];
      vertexData.push(
        data.vertices[index * 2],
        data.vertices[index * 2 + 1],
        logdensity
      );
    }

    return vertexData;
  },

  render: function(gl, matrix) {
    gl.useProgram(this.program);
    
    gl.uniformMatrix4fv(this.uMatrix, false, matrix);

    const features = this.map.querySourceFeatures('density-tileset', {
      sourceLayer: 'OnlyLog_NormalizedTo100-4zhaka'
    });

    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.enableVertexAttribArray(this.aPos);
    gl.enableVertexAttribArray(this.aLogdensity);
    gl.vertexAttribPointer(this.aPos, 2, gl.FLOAT, false, 12, 0);
    gl.vertexAttribPointer(this.aLogdensity, 1, gl.FLOAT, false, 12, 8);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    features.forEach((feature) => {
      const logdensity = feature.properties.logdensity || 0;
      let vertexData = [];

      if (feature.geometry.type === 'Polygon') {
        vertexData = this.processPolygon(feature.geometry.coordinates, logdensity);
      } else if (feature.geometry.type === 'MultiPolygon') {
        feature.geometry.coordinates.forEach(polygonCoords => {
          vertexData = vertexData.concat(this.processPolygon(polygonCoords, logdensity));
        });
      }

      if (vertexData.length > 0) {
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.DYNAMIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, vertexData.length / 3);
      }
    });
  }
};



  map.on('sourcedata', function(e) {
    if (e.sourceId === 'density-tileset' && e.isSourceLoaded) {
      if (!map.getLayer('custom-tessellated-layer')) {
        console.log('Adding custom tessellated layer');
        map.addLayer(customLayer);
      }
    }
  });
});
</script>

</body>
</html>